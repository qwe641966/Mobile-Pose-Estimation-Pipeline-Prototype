mse_data = load('mse_data.mat');
mse_data = mse_data.value;

%ground truth
ground_truths_rotation_quarternions = mse_data(:,1:4);
rotation_matrices_gt = quat2rotm(ground_truths_rotation_quarternions);
ground_truths_trans = mse_data(:,5:7);

%estimated calculations
rotation_vectors_calculated = mse_data(:,8:10);
translation_vectors_calculated = mse_data(:,11:13);

len = size(rotation_vectors_calculated);
rotation_matrices_est = [];

for i = 1:len(1)
    rot_vector = rotation_vectors_calculated(i,:);
	rotation_matrices_est(:,:,i) = rotationVectorToMatrix(rot_vector);
end

% The first three elements of every row specify the rotation axis, 
% and the last element defines the rotation angle (in radians).
axang_gt = rotm2axang(rotation_matrices_gt);
axang_est = rotm2axang(rotation_matrices_est);

% errors calculation
% In this scheme the error is in fact a 3-tuple, 
% the distance error, the axis error, and the angle error.
total_errors = [];

trans_errors = [];
for i = 1:len(1)
	t_error = norm(ground_truths_trans(i,:) - translation_vectors_calculated(i,:));
    trans_errors(i) = t_error;
end

angle_errors = [];
for i = 1:len(1)
	a_error = norm(axang_gt(i,4) - axang_est(i,4));
    angle_errors(i) = a_error;
end

rotations_errors = [];
for i = 1:len(1)
	r_error = norm(cross(axang_gt(i,1:3),axang_est(i,1:3)));
    rotations_errors(i) = r_error;
end

% bar(trans_errors);
% bar(rotations_errors);
% bar(angle_errors);

trans_errors_norm = (trans_errors - mean(trans_errors)) ./ std(trans_errors);
rotations_errors_norm = (rotations_errors - mean(rotations_errors)) ./ std(rotations_errors);
angle_errors_norm = (angle_errors - mean(angle_errors)) ./ std(angle_errors);

title('Errors Normalised (varia=1');
xlabel('Translation Errors');
ylabel('Rotation Errors');
zlabel('Angle Errors');

scatter3(trans_errors_norm,rotations_errors_norm,angle_errors_norm,'filled');
